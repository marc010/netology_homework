# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя

mongo-shell:
1. Найти запрос:
```
db.currentOp({"active" : true,"secs_running":{$gte:180}})
```
2. В выводе интересует поле "opid".
3. Завершить запрос:
```
db.killOp(<opId>)
```
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

```
* Использовать метод `maxTimeMS` в запросах;
* Отслеживать долгие операции и "убивать" их (Но только если это опреции SELECT, чтобы не развалить БД)
Например:alertmanager - сконфигуровать на соответвующие триггеры, и "убивать" 
их; Или через zabbix запускать соответствующие скрипты по триггерам;
* Проведение мониторинга;
* Возможно придется изменить архитектуру приложения, если оно вызывает долгие (зависающие) запросы.
Например: Если приложению нужно изменить данные в БД, следует открывать соединение непосредственно перед
внесением изменений и сразу закрывать его;
```

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

```
Если в реплике много данных, это сильно нагрузит сеть в момент репликации. В этот момент Redis может заблокировать
операции записи из-за нехватки памяти. Кроме того Redis начнет удалять ключи с истекшим сроком действия и это
также вызовет задержку и блокировку операций записи, поскольку в этот момент в БД будет много ключей срок действия
которых заканчивается в одну и ту же секунду.
```

## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

```
* Иногда эта ошибка возникает во время выплонения очень больших запросов. Можоно попробовать увеличить
значение `net_read_timeout` (по умолчанию 30 секунд) до 60 секунд или дольше;
* Также это может произойти, если клиент не успевает установить соединение с сервером. В этом случае,
можоно попробовать увеличить значение `connect_timeout`;
* Проблема может быть вызвана превышением размера сообщения. В этом случае можно увеличить значение 
параметра `max_allowed_packet`;
```

## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

```
OOM Killer завершает работу postgresql из-за высокого потребления RAM.

OOM Killer — механизм ядра Linux, который при исчерпании доступной памяти принудительно завершает
отдельные процессы на сервере для освобождения RAM. Освободившаяся память передается ядру ОС, а после
перенаправляется тому процессу, которому ее было недостаточно.

Решить данную проблему можно путем увелечения RAM серваера и изменения конфигурации PostgreSQL.
Параметры находятся в файле postgresql.conf. 

* Параметр `shared_buffers` определяет, сколько памяти выделяется серверу для кэширования данных.
Рекомендуется устанавливать данное значение от 15 % до 25 % от RAM сервера;
* Параметр `work_mem` определяет объем памяти, который будет использоваться внутренними операциями
сортировки и хеш-таблицами перед записью во временные файлы на диске. Рекомендуется установливать данное
значение в соответсвии с формулой: Total RAM * 0.25 / max_connections;
* Параметр `maintenance_work_mem` определяет максимальный объем памяти, который будет использоваться
операциями обслуживания, такими как vacuum, create index, alter table и foreign key. Рекомендуется
установливать данное значение в соответсвии с формулой:Total RAM * 0.05;
* Параметр `effective_cache_size` определяет сколько памяти доступно для кэширования диска операционной
системой и самой базой данных. Рекомендуется установливать данное значение равным 50% от общего объема RAM;
```