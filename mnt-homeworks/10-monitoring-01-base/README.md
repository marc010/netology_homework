# Домашнее задание к занятию "13.Введение в мониторинг"

## Обязательные задания

1. Вас пригласили настроить мониторинг на проект. На онбординге вам рассказали, что проект представляет из себя 
платформу для вычислений с выдачей текстовых отчетов, которые сохраняются на диск. Взаимодействие с платформой 
осуществляется по протоколу http. Также вам отметили, что вычисления загружают ЦПУ. Какой минимальный набор метрик вы
выведите в мониторинг и почему?

#### Ответ:

Что касается ресурсов системы на которой будет запущен проект:
* Объем свободного места на диске;
* Количество inode - важно следить за количеством файловых дескрипторов, особено если каждый отчет сохраняется на диск. В случае если они закончатся корректная работа системы прекатится;
* Объем свободной оперативной памяти;
* Загрузка CPU - общая загрузка системными вызовами и загрузка на вычисления в процентах;

Что касается самого проекта:
* Количество HTTP запросов;
* Отношение HTTP запросов с кодом 200 ко всем HTTP запросам;
* Среднее время на формирование отчета;

---

2. Менеджер продукта посмотрев на ваши метрики сказал, что ему непонятно что такое RAM/inodes/CPUla. Также он сказал, 
что хочет понимать, насколько мы выполняем свои обязанности перед клиентами и какое качество обслуживания. Что вы 
можете ему предложить?

#### Ответ:

Можно в качестве индикатора уровня обслуживания (SLI) предложить фактическое измеренное значение успешных HTTP ответов на все запросы.
Это поможет понять насколько сервис выполняет цели уровня обслуживания (SLO).

---

3. Вашей DevOps команде в этом году не выделили финансирование на построение системы сбора логов. Разработчики в свою 
очередь хотят видеть все ошибки, которые выдают их приложения. Какое решение вы можете предпринять в этой ситуации, 
чтобы разработчики получали ошибки приложения?

#### Ответ:

Как вариант, можно просматриваить системные логи, где развернуты проекты и пытаться среди них искать ошибки связанные с работой проекта.

---

4. Вы, как опытный SRE, сделали мониторинг, куда вывели отображения выполнения SLA=99% по http кодам ответов. 
Вычисляете этот параметр по следующей формуле: summ_2xx_requests/summ_all_requests. Данный параметр не поднимается выше 
70%, но при этом в вашей системе нет кодов ответа 5xx и 4xx. Где у вас ошибка?


#### Ответ:
В данной формуле не учтены информационные (1хх) HTTP коды и коды перенаправления (3хх).
`summ_1xx_requests + summ_2xx_requests + summ_3xx_requests/summ_all_requests`

---

## Дополнительное задание (со звездочкой*) - необязательно к выполнению

Вы устроились на работу в стартап. На данный момент у вас нет возможности развернуть полноценную систему 
мониторинга, и вы решили самостоятельно написать простой python3-скрипт для сбора основных метрик сервера. Вы, как 
опытный системный-администратор, знаете, что системная информация сервера лежит в директории `/proc`. 
Также, вы знаете, что в системе Linux есть  планировщик задач cron, который может запускать задачи по расписанию.

Суммировав все, вы спроектировали приложение, которое:
- является python3 скриптом
- собирает метрики из папки `/proc`
- складывает метрики в файл 'YY-MM-DD-awesome-monitoring.log' в директорию /var/log 
(YY - год, MM - месяц, DD - день)
- каждый сбор метрик складывается в виде json-строки, в виде:
  + timestamp (временная метка, int, unixtimestamp)
  + metric_1 (метрика 1)
  + metric_2 (метрика 2)
  
     ...
     
  + metric_N (метрика N)
  
- сбор метрик происходит каждую 1 минуту по cron-расписанию

Для успешного выполнения задания нужно привести:

а) работающий код [python3-скрипта](./metrics/awesome-monitoring.py)

```python
#!/usr/bin/env python3

import re
import json
from datetime import datetime

def get_loadavg():
    with open('/proc/loadavg', 'r') as f:
        values = f.read()
    la_1, la_5, la_15, cur_proc, newest_pid = values.split(' ')
    loadavg = {}
    loadavg['la_1'] = la_1
    loadavg['la_5'] = la_5
    loadavg['la_15'] = la_15
    return loadavg

def get_uptime():
    with open('/proc/uptime', 'r') as f:
    	values = f.read()
    uptime, idle_proces = values.split(' ')
    time = {}
    time['uptime'] = uptime
    return time

def get_meminfo():
    with open('/proc/meminfo', 'r') as f:
        file = f.read()
    meminfo = file.split('\n')
    for line in meminfo:
        reg = re.match(r'^(\w*):\s*(\d*)\skB', line)
        if reg and reg.group(1) == 'MemTotal':
            MemTotal = reg.group(2)
        elif reg and reg.group(1) == 'MemFree':
            MemFree = reg.group(2)
        elif reg and reg.group(1) == 'MemAvailable':
            MemAvailable = reg.group(2)
    info = {}
    info['MemTotal'] = MemTotal
    info['MemFree'] = MemFree
    info['MemAvailable'] = MemAvailable
    return info

def get_cpuinfo():
    with open('/proc/cpuinfo', 'r') as f:
        file = f.read()
    cpuinfo = file.split('\n')
    cpu_mhz = []
    info = {}
    for line in cpuinfo:
        reg = re.match(r'^(cpu MHz)\s*:\s(\d*)', line)
        if reg:
            cpu_mhz.append(reg.group(2))
    info['cpu_mhz'] = cpu_mhz
    return info


if __name__ == "__main__":

    cur_datetime = datetime.now()
    date = cur_datetime.strftime('%Y-%m-%d')
    cur_timestamp = cur_datetime.strftime('%s')
    logs = f"/var/log/{date}-awesome-monitoring.log"

    data = {'timestamp': cur_timestamp, **get_loadavg(), **get_uptime(), **get_meminfo(), **get_cpuinfo()}
    
    with open(f"/var/log/{date}-awesome-monitoring.log", 'w') as f:
    	f.write(json.dumps(data))
```

б) конфигурацию cron-расписания

```
SHELL=/bin/bash
*  *  *  *  * root /scripts/awesome-monitoring.py
```

в) пример верно сформированного 'YY-MM-DD-awesome-monitoring.log', имеющий не менее 5 записей

```
{"timestamp": "1679773252", "la_1": "0.72", "la_5": "0.59", "la_15": "0.46", "uptime": "18784.75", "MemTotal": "16173804", "MemFree": "6199672", "MemAvailable": "9886348", "cpu_mhz": ["695", "615", "992", "3203", "973", "3172", "476", "3217"]}
```

P.S.: количество собираемых метрик должно быть не менее 4-х.
P.P.S.: по желанию можно себя не ограничивать только сбором метрик из `/proc`.
